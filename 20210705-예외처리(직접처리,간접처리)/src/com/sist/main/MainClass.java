package com.sist.main;
// 문법 
/*
 *     변수(데이터형) = 연산자 = 제어문 = 배열 = 메소드 = 클래스 
 *     클래스 : 캡슐화 / 상속 , 포함 / 오버로딩 , 오버라이딩(다형성)
 *            =====
 *            접근 지정어 : private < default < protected < public 
 *            프로그램 
 *               = 변수 : 은닉화 (private)
 *               = 메소드 : 다른 클래스와 연결 (public)
 *               = 생성자 : 클래스를 저장하기 위해 사용(new 생성자()) => 초기화(메버변수) public
 *               = 클래스 : (public , default) => public 
 *               = 객체 (부품) => 연결해서 사용(조립)
 *               ====================================================================
 *               변수사용
 *               ======
 *                 = 멤버변수 : private 데이터형 변수명 
 *                 = 공유변수 : ==> private static 데이터형 변수명;
 *                 = 지역변수(메소드에서만 사용) : 사용할 수 있는 제어자 => final(상수)
 *                 변수 => 읽기(메모리에 값을 가지고 온다) , 쓰기(메모리에 값 저장)
 *                        private => 다른 클래스에서 연결 할 수 없다 
 *                                   연결을 위해 ==> getter/setter ==> 
 *                                                ==============
 *                                                set변수명() , get변수명() => 캡슐화 
 *                 => 변수 반드시 초기화 
 *                    => 멤버변수 (클래스 영역에 설정 : 자동 초기화)
 *                       1) 초기화 블록 {}
 *                       2) 생성자 
 *                    => 지역변수는 초기화를 프로그래머 설정(반드시 설정)
 *                    => 직접 대입 , 사용자의 입력값을 받아서 처리 , 파일 읽기 , 데이터베이스 
 *                       ========  =============================================
 *                         선언                  구현 ==> 구현은 반드시 {}안서 설정 
 *               메소드 : 용도=>다른 클래스와 연결(통신) => 한가지 기능만 수행이 가능 (재사용)
 *                       새로운 메소드 제작 (오버로딩)
 *                       기존에 있는 메소드 변경 (오버라이딩)
 *               ===============================================================
 *                                   오버로딩         오버라이딩 
 *               ===============================================================
 *                 메소드명               O              O
 *               ===============================================================
 *                 리턴형                X               O
 *               ===============================================================
 *                 매개변수              X(갯수,데이터형)    O
 *               ===============================================================
 *                                                   접근지정어가 확장이 가능 
 *                                  private  < default < protected < public 
 *                                  
 *                private : 자신의 클래스안에서만 사용이 가능 
 *                default : 자신의 클래스,같은 패키지안에서 접근이 가느
 *                protected : 자신의 클래스 , 같은 패키지 , 다른 패키지 => 상속을 받은 클래스
 *                public : 모든 클래스(패키지와 상관이 없다)
 *               ===============================================================
 *               클래스의 종류 
 *               ==========
 *               1. 일반 클래스 (스프링 : POJO) => 독립적인 클래스 
 *                  public class ClassName
 *                  {
 *                     ==================
 *                       멤버변수 
 *                         = 인스턴스 변수
 *                         = 공유 변수 
 *                     ==================
 *                       생성자 
 *                         오버로딩이 가능 => 여러개를 제작할 수 있다 
 *                         없는 경우도 있다 => 컴파일러가 자동으로 생성 (디폴트 생성자)
 *                     ==================
 *                       메소드 : 여러개 , 한개... => 기능 설정 
 *                     ==================
 *                  }
 *                  
 *               2. 몸통이 없는 클래스 (메소드가 구현이 안된 미완성된 클래스) => 설계 (프로그래머가 구현해서 사용)
 *                  =============== 자신의 클래스로 메모리에 저장 할 수 없다 (구현된 하위클래스를 이용해서 메모리 할당)
 *                     = 서로 다른 클래스를 연결해서 사용 (여러개를 모아서 한개의 이름을 제어)
 *                     = 개,돼지,소, 말, 인간 ===> 동물(추상클래스)
 *                     = 변수여러개 => 배열이름(한개)으로 제어
 *                     = 비슷한 클래스 => 추상클래스,인터페이스로 제어(한개만 생성)  
 *                  =  추상클래스 
 *                     public abstract class ClassName
 *                     {
 *                         =====================
 *                          멤버변수 
 *                            = 인스턴스 변수
 *                            = 공유변수
 *                         =====================
 *                          생성자 
 *                         =====================
 *                          메소드 
 *                            = 구현이 안된 메소드 (추상메소드)
 *                              public abstract 리턴형 메소드(매개변수...);
 *                              => 상속을 받은 경우에 	반드시 구현해서 사용 
 *                            = 구현이 된 메소드 
 *                              public 리턴형 메소드(매개변수...)
 *                              {
 *                              }
 *                              => 필요하면 오버라이딩해서 사용 , 있는 그대로 사용이 가능 
 *                              메소드는 {} 구현이 된다 
 *                         =====================
 *                     }
 *                  =  인터페이스 (웹에서 가장 많이 사용) => 스프링의 기본 연결 
 *                     =========================== 결합성을 낮게 만든다 
 *                     == 추상클래스의 일종 (메소드가 거의 => 추상메소드 , 변수는 상수형 변수)
 *                     public interface Interface명
 *                     {
 *                        ========================
 *                         변수 : 반드시 값을 지정해서 사용=> 상수형
 *                         (public static final) int a=10;
 *                         =====================
 *                                생략 
 *                        ========================
 *                          메소드 
 *                          (public abstract) 리턴형 메소드(매개변수);
 *                          ========
 *                          모든 메소드는 public 
 *                        ========================
 *                        jdk1.8 설정
 *                        ========================
 *                          구현이 가능한 메소드가 추가 
 *                          default메소드 , static메소드
 *                          public default 리턴형 메소드(매개변수)
 *                          {
 *                          }
 *                          public static 리턴형 메소드(매개변수)
 *                          {
 *                          }
 *                        ========================
 *                     }
 *                     
 *                  3. 내부클래스 : 윈도우 , 네트워크 , 쓰레드(앱 => 카카오) : 서버 직접 제작...
 *                     = 멤버 클래스 : 변수나 메소드를 두개이상의 클래스에서 쉽게 접근이 가능하게 제작 
 *                         public class ClassName(윈도우)
 *                         {
 *                             ================
 *                              멤버변수
 *                             ================
 *                              메소드
 *                             ================
 *                              class ClassName(쓰레드)
 *                              {
 *                                 여기서 => 위에 있는 멤버변수,메소드를 자유롭게 사용이 가능 
 *                              }
 *                             ================
 *                         }
 *                         =======> 분석 (MapReduce) => 데이터분석 (코모란,꼬꼬마..)
 *                     = 익명의 클래스 : 상속이 없이 오버라이딩이 가능하게 만든는 클래스
 *                       class A
 *                       {
 *                          public void display(){}
 *                       }
 *                       class B extends A
 *                       {
 *                          public void display(){}를 재정의 => 오버라이딩
 *                       }
 *                       
 *                       class A
 *                       {
 *                          public void display(){}
 *                       }
 *                       class B
 *                       {
 *                           A a=new A()
 *                           {
 *                              public void display(){} // 오버라이딩 
 *                           }
 *                       }
 *              ===============================================================
 *              문제 => 오류 (에러) 
 *                  => 오류를 방지하는 프로그램 => 예외처리 (조건문으로 사용)
 *                  => 에러) 프로그램이 실행될 경우 => 비정상 종료 , 멈춤상태 
 *                  ================================================
 *                  시스템에러 , 프로그램상에서 에러 (사용자가 입력을 잘못한 경우 , 프로그래머 실수)
 *                  =======   ======================================================
 *                   처리할 수 있는 에러가 아니다    처리가 가능한 에러 
 *                   ======================    ==============
 *                          에러   (Error)           예외처리 (수정이 가능한 에러) Exception
 *                   예) 메모리가 부족하다              예) 사용자가 정수입력 => 문자열
 *                      윈도우가 멈춤                     배열의 인덱스 초과
 *                      서버가 속도가 늦어서 접근이 불가능    소스상에서 수정이 가능 (서버주소가 틀리다,
 *                                                     파일명을 잘못 사용...
 *                      웹크롤링 => 접근 거부              SQL(오라클)문장이 틀리다
 *                   ==> 예외처리 (사전에 오류 방지하는 프로그램) => 비정종료를 방지하고 정상상태를 유지 
 *                       ======
 *                       1) 예외가 났을 경우 => 복구 => try ~ catch 
 *                                                 ====  ======> 복구하는 위치
 *                                                 정상수행이 가능  
 *                                                 => catch를 사용해서 복구(소스가 변경이 된 것이 아니라)
 *                                                    단지 => 점프를 해서 다음의 문장을 수행 
 *                          try
 *                          {
 *                              int a=10; => 정상수행
 *                              int b=0;  => 정상수행 
 *                              int c=a/b; => 0으로 나눠서 오류 발생 ==> catch로 이동 점프
 *                              System.out.println(c); => 수행하지 않는다 
 *                          }catch()
 *                          {
 *                             복구 처리 => 다음 / 처음으로 수행 
 *                          }
 *                          System.out.println("프로그램 종료!!")
 *                                                    
 *                                                    
 *                       2) 예외가 났을 경우 => 회피
 *                          메소드() throws .....  ==> 시스템에서 처리 (알려만 준다)
 *                          
 *                예외처리와 관련된 클래스 
 *                 = Check Exception : 컴파일시 (javac) ==> 예외처리를 하지 않으면 컴파일시 에러가 발생 
 *                                     Document doc=Jsoup.connection(URL).get();
 *                 = UnCheck Exception : 실행시 (java) ===> 생략이 가능 
 *                예외처리 구조(상속도) : 예외처리도 순서가 있다 
 *                           Object : 모든 자바 클래스의 최상위 
 *                              |
 *                         Throwsable 
 *                             |
 *                      ==================================
 *                      |                                |
 *                    Error                         Exception
 *                      |                                |
 *                  OutOfMemoryError            ==========================
 *             메모리를 더 이상 사용할 수 없다        |(uncheck)               |(check Exception)
 *                                          RuntimeException
 *                                               | 생략이 가능한 에러
 *                                           ArrayIndexOutOfBoundsException
 *                                             => 배열의 인덱스 초과 
 *                                             int[] arr=new int[2];
 *                                             int[0]=10;
 *                                             int[2]=20; => Error 배열 초과
 *                                           ArithmeticException
 *                                             => 0으로 나눌 경우 
 *                                             int a=10/0;=> 
 *                                           NumberFormatException
 *                                             String s="10 ";
 *                                             => 정수형 변환이 안된다 
 *                                             Integer.parseInt(s); ==> 웹에서는 데이터 전송시
 *                                                                      문자열 
 *                                                                      1 ==> (X)
 *                                                                      "1" ==> (O)
 *                                           ClassCastException
 *                                             => class A
 *                                                class B
 *                                                A a=new A();
 *                                                B b=new B();
 *                                                
 *                                                b=(B)a; => CastException
 *                                                관련이 없는 클래스는 형변환을 할 수 없다 
 *                                                ==============
 *                                                  1. 상속 , 2. 포함 ==> 형변환이 가능 
 *                                                
 *                                           NullPointerException
 *                                             => class A
 *                                                {
 *                                                   public void display()
 *                                                   {
 *                                                   }
 *                                                }
 *                                                
 *                                                A a;  ==> NullPointerException
 *                                                ==== a는 참조변수 => 주소가 없는 경우
 *                                                클래스 , 배열은 여러개를 동시에 제어 => 메모리 주소
 *                                                a.display();
 *                                        ==================================================
 *                                        Check Exception => 반드시 예외 처리를 한다 
 *                                        =============== 컴파일러가 예외처리를 해는지 여부 확인 
 *                                                        (없는 경우에 바로 에러출력)
 *                                        1) IOException : 파일 입출력 
 *                                                         ========= (파일 경로명..)
 *                                        2) MalformedURLException : URL주소 (네트워크)
 *                                                         URL주소가 틀린다, 서버주소가 틀릴경우 
 *                                        3) SQLException : SQL문장 틀린경우(오라클 연동)
 *                                        4) InterruptedException: 쓰레드 충돌을 방지할 때 사용 
 *                                             => 데들락 , 스타베이션 (기술면접)
 *                                                => 쓰레드 (동기화,비동기화)
 *                                                         ======
 *                                                         한개의 쓰레드가 작업을 종료후 
 *                                                         다음 쓰레드가 동작 (쓰레드 작업하는 과정에서 
 *                                                            멈추는 상태)
 *                                        5) ClassNotFoundException: 스프링
 *         예외처리 방법 : 조건문으로 가능 여부 확인 => 조건문으로 해결 할 수 없는 예외(예외처리)
 *         = 예외 복구 (프로그래머가 처리) => 중간에 프로그램을 종료하지 않는 프로그램을 만들 경우 사용 
 *            => 예외 직접 처리
 *               try ~ catch ~ finally (O)
 *         = 예외 회피 (시스템에 알려주는 방법)
 *            => 예외 간접 처리 
 *               throws (O)
 *         = 예외 전환 
 *            => 임의로 발생 (에러를 일부로 발생=> 프로그램이 견고한지 확인) : 배포 => 테스터
 *               throw 
 *         = 지원하지 않는 예외 : 사용자 정의 (예외처리를 제작할 수 있다) => if문
 *         
 *         1) 직접 처리 형식 (try~catch)
 *            try
 *            {
 *                평상시 만드는 모든 소스코드(정상적으로 수행 가능한 문장)
 *                => 에러가 발생 할 수도 있다 
 *            }catch(예외처리의 종류)
 *            {
 *                => 에러가 발생했을 경우 => 복구할 수 있는 소스코딩을 만든다 
 *            }
 *            finally
 *            {
 *               => 생략이 가능 
 *               => 서버 종료 , 파일 닫기, 데이터베이스 종료 
 *               => try , catch와 관련이 없이 무조건 수행이 가능한 문장 
 *            }
 *            
 *            => 프로그램 전체를 예외처리 할 수 도 있다 
 *            => 부분적으로 처리도 가능 하다 (발생 가능한 위치에서 예외 처리가 가능하다)
 *            try
 *            {
 *                1문장
 *                2문장
 *                3문장
 *                4문장
 *                5문장
 *            }
 *            catch()
 *            {
 *                예외처리문장 
 *            }
 *            
 *            
 *            1문장
 *            2문장 
 *            try
 *            {
 *               3문장
 *               4문장
 *            }
 *            catch()
 *            {
 *               오류처리문장
 *            }
 *            5문장
 *            
 *            
 *            ===================
 *            try
 *            {
 *               for(int i=0;i<=10;i++)
 *               {
 *                   실행문장 
 *                   => i==5에서 에러발생 ==> catch로 이동  ==> 0,1,2,3,4 => 처리 
 *               }
 *            }catch()
 *            {
 *            }
 *            
 *            
 *            for(int i=0;i<=10;i++)
 *            {
 *                try
 *                {
 *                    실행문장
 *                    => i==5일때 에러 발생 ==> catch로 이동 ===> 0,1,2,3,4 , 6,7,8,9,10 
 *                }catch()
 *                {
 *                    에러처리문장  ==> 증가식으로 이동 
 *                }
 *            }
 *            
 */
public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*try
		{
			for(int i=1;i<=10;i++)
			{
				if(i==5)
				{
					System.out.println(i/0);//catch => 복구 ==> i=1~4정상 수행 
					// for을 종료하고 빠져 나간다 
				}
				System.out.println("i="+i);
			}
		}catch(Exception e)
		{
			System.out.println(e.getMessage());
		}
		System.out.println("프로그램 종료!!");*/
		for(int i=1;i<=10;i++)
		{
			try
			{
				if(i==5)
				{
					System.out.println(i/0);
				}
				System.out.println("i="+i);
			}catch(Exception ex)
			{
				System.out.println(ex.getMessage()); // for의 증가식으로 이동 i++
			}
		}
		System.out.println("프로그램 종료!!");
        
	}

}










