/*
 *      1. 데이터 => 메모리에 저장 
 *         ===================
 *         1) 한개의 데이터 저장 
 *            변경할 수 있다  ==> 변수 
 *            변경할 수 없다  ==> 상수  (final)
 *            정수(int ,long) , 실수(double) , 논리(boolean:제어문) ,
 *            문자열(String)
 *            => 형식) 데이터형 변수명=값 (초기화)
 *         2) 같은 데이터형 여러개를 동시에 저장 
 *            ==========
 *            배열 : 인덱스 (메모리 연속적으로 배치) => 0부터 시작 
 *            => 형식) 데이터형[] 배열명=값
 *                    = 데이터형[] 배열명={값,값...}
 *                    = 데이터형[] 배열명=new 데이터형[갯수]
 *                      ==============================
 *                        자동 초기화 
 *                        int => 0 , long => 0L , boolean => false
 *                        String => null (주소가 없는 경우)
 *                        String s; => null
 *                        String s="" => 공백이라는 값
 *            => 1차원 배열 
 *        ==============================================================
 *        3) 다른 데이터형을 여러개를 동시에 저장 
 *           ==========
 *           클래스 : 한개에 대한 모든 정보 => 영화정보 , 뮤직정보 , 사람 정보....
 *                  여러개일때 사용 => new를 사용하면 메모리가 다른 위치에 저장 
 *        ===============================================================
 *        4) 메모리에 저장 : RAM (휘발성) => 프로그램 종료시 사라진다 
 *           = File (영구적으로 저장)
 *           ***= RDBMS (관계형 데이터베이스 *******) => 오라클 , 마리아디비, MySQL => MongoDB...
 *        ===============================================================
 *        
 *     2. 연산자 / 제어문 
 *        데이터 처리 (요청) => 가공 
 *        연산자 : ++,-- , ! , (type) , 산술연산자 , 비교연산자 , 논리연산자 , 대입(= , += , -=)
 *        제어문 : 조건문(if , if~else , 다중조건문) , 반복문(for , while) , 반복제어문(break)
 *        
 *        연산자 + 제어문 = 메소드 : 한개의 기능을 만들기 위해 명령문 여러개를 모아서 관리)
 *                       ===== 재사용
 *     3. 프로그램 : 같은 기능끼리 묶어서 사용 
 *     ==============================
 *        게시판 :
 *                목록출력 => 메소드 
 *                글쓰기
 *                내용보기
 *                수정 
 *                답변
 *                삭제
 *                찾기 
 *     ==============================
 *     
 *     배열 : 같은 데이터형  => double[] arr={10,'A'....}
 *                          double d=10; ==> d=10.0
 *                          double d='A'; ==> d=65.0 ==> 자동 형변환
 *                          대입 : 왼쪽에 있는 데이터형이 크거나 같다
 *           배열은 반드시 갯수를 지정 (length)
 *           1) int[] arr={10,20,30,40,50} ==> 5개의 정수메모리를 확보 (연속적)
 *           2) int[] arr=new int[갯수];
 *           ============================ 단점 : 고정적 (갯수를 늘릴 경우에는 반드시 더 큰 배열을 생성
 *                                              복사를 한다)
 *                                              for => arraycopy() 
 *           데이터 저장된 메모리마다 인덱스번호를 부여한다  (0)
 *           int[] arr={10,20,30,40,50};
 *           
 *            배열 시작의 주소(주소를 참조해서 데이터 가지고 오기) ==> 참조형 (배열,클래스:주소접근 연산자 '.'= 변수+메소드)
 *            Stack(주소)                      실제 데이터 저장 (Heap)
 *             arr 
 *           ======             ===============================================
 *             100               10    |   20     |   30    |  40     |   50
 *           ======            |===============================================
 *                           100     104        108       112        116
 *                               arr[0]   arr[1]     arr[2]    arr[3]    arr[4]
 *                               ======
 *                               주소가 arr인 첫번째 값 : 데이터 읽기 (0) , 데이터 갯수는 length-1
 *                               => for , while => 소스를 줄여서 사용이 가능 
 *           => 정수형 선언 
 *              int[] 배열명={값...} 
 *           => 실수형 선언
 *              double[] 배열명={값...}
 *           => 문자열 선언             
 *              String[] 배열명={값....}
 *           => 배열 ==> 같은 데이터형 모아서 관리 (기능에 따라서 모아서 관리)
 *              예) 영화 
 *                  영화명 , 감독 , 출연 , 장르 , 스토리 ===> 배열 5개 (인덱스를 처리)
 *                  ============================== 인덱스 번호를 이용해서 만든다 
 *                    
 *                       
 *                 
 */
// 1. 달력  ==> 사용자 (년도 / 월)  ==> 요일 (난수 => 중복=> 숫자야구게임)
//    ======================== Calendar 
/*
 *    달력 => 1년 1월 1일 ~ 현재까지의 총날 수 구한다  ==> %7 => 요일 구한다 
 *    
 *    1. 전년도까지 합
 *    2. 전달까지 합
 *    3. 요청한 날짜까지
 *    ================ 총합 
 *    %7 ==> 요일을 구한다 
 */
// 입력 => Scanner 
import java.util.Scanner; // 기존에 만들어진 클래스를 불러올때 사용 (라이브러리(자바에서 제공..외부에서 제공),사용자 정의)
// import ==> 전체 java.util.*, 한개씩 => java.util.클래스명 
public class 자바기본문법 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
        // 1. 사용자로 부터 요청값을 받는다 ==> 프로그램 (Actor) : user
		// 키보드 입력값 
		Scanner scan=new Scanner(System.in); // 입출력 (System.in.System.out)
		System.out.print("년도 입력:");
		int year=scan.nextInt();
		
		System.out.print("월 입력:");
		int month=scan.nextInt();
		
		System.out.print("일 입력:");
		int day=scan.nextInt();
		/*
		 *    윤년 조건 
		 *    4년 마다 
		 *    100년 마다 제외
		 *    400년 마다 
		 */
		// 가공 ==> 요일을 출력 
		// 1. 1년도 1월 1일부터 전년도까지의 총날 수 
		int total=(year-1)*365 + (year-1)/4 
				               - (year-1)/100
				               + (year-1)/400;  // 365, 366 => 윤년을 포함 
		// 2. 전달까지의 합 
		int[] lastday={31,28,31,30,31,30,
				       31,31,30,31,30,31}; // 365
		//입력한 날짜가 윤년일 경우 
		if((year%4==0 && year%100!=0)||(year%400==0))
			lastday[1]=29;
		else
			lastday[1]=28;
		
		for(int i=0;i<month-1;i++)
		{
			total+=lastday[i];
		}
		
		// 요일한 일 
		total+=day;
		// 요일 구하기 
		int week=total%7; 
		String[] strWeek={"일","월","화","수","목","금","토"};
		System.out.printf("%d년 %d월 %d일은 %s요일입니다",year,month,day,strWeek[week]);
		/*switch(week)
		{
		case 0:
			System.out.printf("%d년 %d월 %d일은 일요일입니다",year,month,day);
			break;
		case 1:
			System.out.printf("%d년 %d월 %d일은 월요일입니다",year,month,day);
			break;
		case 2:
			System.out.printf("%d년 %d월 %d일은 화요일입니다",year,month,day);
			break;
		case 3:
			System.out.printf("%d년 %d월 %d일은 수요일입니다",year,month,day);
			break;
		case 4:
			System.out.printf("%d년 %d월 %d일은 목요일입니다",year,month,day);
			break;
		case 5:
			System.out.printf("%d년 %d월 %d일은 금요일입니다",year,month,day);
			break;
		case 6:
			System.out.printf("%d년 %d월 %d일은 토요일입니다",year,month,day);
			break;
		}*/
	}

}








